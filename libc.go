package b2

import (
	"reflect"
	"sync/atomic"
	"unsafe"
)

// VaList fills a varargs list at p with args and returns p.  The list must
// have been allocated by caller and it must not be in Go managed memory, ie.
// it must be pinned. Caller is responsible for freeing the list.
//
// This function supports code generated by ccgo/v4.
//
// Note: The C translated to Go varargs ABI alignment for all types is 8 on all
// architectures.
func vaList(p uintptr, args ...interface{}) (r uintptr) {
	if p&7 != 0 {
		panic("internal error")
	}

	r = p
	for _, v := range args {
		switch x := v.(type) {
		case int:
			*(*int64)(unsafe.Pointer(p)) = int64(x)
		case int32:
			*(*int64)(unsafe.Pointer(p)) = int64(x)
		case int64:
			*(*int64)(unsafe.Pointer(p)) = x
		case uint:
			*(*uint64)(unsafe.Pointer(p)) = uint64(x)
		case uint16:
			*(*uint64)(unsafe.Pointer(p)) = uint64(x)
		case uint32:
			*(*uint64)(unsafe.Pointer(p)) = uint64(x)
		case uint64:
			*(*uint64)(unsafe.Pointer(p)) = x
		case float32:
			*(*float64)(unsafe.Pointer(p)) = float64(x)
		case float64:
			*(*float64)(unsafe.Pointer(p)) = x
		case uintptr:
			*(*uintptr)(unsafe.Pointer(p)) = x
		default:
			sz := reflect.TypeOf(v).Size()
			copy(unsafe.Slice((*byte)(unsafe.Pointer(p)), sz), unsafe.Slice((*byte)(unsafe.Pointer((*[2]uintptr)(unsafe.Pointer(&v))[1])), sz))
			p += roundup(sz, 8)
			continue
		}
		p += 8
	}
	return r
}

func roundup(n, to uintptr) uintptr {
	if r := n % to; r != 0 {
		return n + to - r
	}

	return n
}

func atomicStoreNInt32(ptr uintptr, val int32, memorder int32) {
	atomic.StoreInt32((*int32)(unsafe.Pointer(ptr)), val)
}

func atomicStoreNUint32(ptr uintptr, val uint32, memorder int32) {
	atomic.StoreUint32((*uint32)(unsafe.Pointer(ptr)), val)
}

func atomicLoadNInt32(ptr uintptr, memorder int32) int32 {
	return atomic.LoadInt32((*int32)(unsafe.Pointer(ptr)))
}

func atomicLoadNUint32(ptr uintptr, memorder int32) uint32 {
	return atomic.LoadUint32((*uint32)(unsafe.Pointer(ptr)))
}

func int32FromInt32(n int32) int32         { return n }
func int32FromInt64(n int64) int32         { return int32(n) }
func int32FromUint8(n uint8) int32         { return int32(n) }
func int32FromUint16(n uint16) int32       { return int32(n) }
func int32FromUint32(n uint32) int32       { return int32(n) }
func int32FromUint64(n uint64) int32       { return int32(n) }
func uint8FromInt32(n int32) uint8         { return uint8(n) }
func uint16FromInt32(n int32) uint16       { return uint16(n) }
func uint32FromInt32(n int32) uint32       { return uint32(n) }
func uint64FromInt32(n int32) uint64       { return uint64(n) }
func uint64FromInt64(n int64) uint64       { return uint64(n) }
func uint64FromUint64(n uint64) uint64     { return n }
func float32FromInt32(n int32) float32     { return float32(n) }
func float32FromFloat32(n float32) float32 { return n }
func float64FromFloat64(n float64) float64 { return n }
func uintptrFromInt32(n int32) uintptr     { return uintptr(n) }

func boolInt32(b bool) int32 {
	if b {
		return 1
	}
	return 0
}

func boolUint8(b bool) uint8 {
	if b {
		return 1
	}
	return 0
}

func boolUint32(b bool) uint32 {
	if b {
		return 1
	}
	return 0
}
